import drawloop
from circlepack import CirclePack
from mobidisc import is_self_overlapping
from drawloop import CircleAssignments
import numpy as np
import math
import vector
import queue


if __name__ == "__main__":
  example_loop = ranloop.generate_planar(6)
    #example_loop = perm.Multiloop([[-4, -3, 1, -1], [3, 4, -2, 2]])
    #example_loop.inf_face = [-3, -1, 4, 2]
    
    #example_loop = perm.Multiloop([[3, 10, -7, -2], [8, 2, 9, -4], [-10, 5, -9, 7], [-6, 6, -3, -5], [-8, 4, 1, -1]])
    #example_loop.inf_face = [-6]
    
    #example_loop = perm.Multiloop([[13,16,-14,-1], [6,1,-7,-2], [2,5,-3,-6], [11,4,-12,-5], [7,10,-8,-11], [14,9,-15,-10], [3,12,-4,-13], [8,15,-9,-16]])

    loop_to_circles = drawloop.generate_circles(example_loop)
    packed_circles = CirclePack(
        loop_to_circles["internal"], loop_to_circles["external"]
    )
    print(example_loop)
    drawloop.drawloop(packed_circles, sequences=loop_to_circles["sequences"], scale=500)
    drawloop.drawloop(packed_circles, sequences=loop_to_circles["sequences"], assignments=loop_to_circles["assignments"], scale=500)
    
    
    print(f"sequences: {loop_to_circles['sequences']}")
    n = len(example_loop.sig)  # num of verts per row
    q = [[0 for _ in range(n)] for _ in range(n)]
    
    points_already_covered = queue.Queue()
    
    print(f"sig:{example_loop.sig}")

    # treat top row as  start
    def build_matrix(sequences: list[list[int]], assignments: CircleAssignments, circle_dict: dict):
       
        # also need to catch out of bounds error or move to next sequence
        # catch later
        #while(not points_already_covered.empty() or sequences[curr_sequence]["circle_ids"].contains() ):
            
        curr_seq = 0
        ci = list(sequences[curr_seq]["circle_ids"])
        ci_fil = []
        
        inv_vert_map = {val: key for key, val in assignments.vertices.items()}
        # filter to get only vert sequence
        for i in range(len(ci)):
            if(assignments.vertices.get(ci[i]) != None):
                ci_fil.append(ci[i])
                
        print(ci)
        print(ci_fil)
                    
        for _ in range(n):
            for i in range(n):
                q[i % n][ (i+1) % n ] = 1
                
                dict_item1 = circle_dict.get(ci[i % n])
                dict_item2 = circle_dict.get(ci[(i + 1) % n])
                dict_item3 = circle_dict.get(ci[(i + 2) % n])
                
                # from tuple of 2 complex numbers to floats
                point1 = (dict_item1[0].real, dict_item1[1].real)
                point2 = (dict_item2[0].real, dict_item2[1].real)
                point3 = (dict_item3[0].real, dict_item3[1].real)
                
                q[i % n][ (i+2) % n ] = 1 if point_maintains_convex(point2, point1, point3) else 0
              
        
        for i in range(n):
            for j in range(3, n):
                
                #first cond, Qij = Qkj = 1
                k = (j + i) / 2
                k = int(k - (k % 1))
                
                if(not (q[i][k] == 1 and q[k][j] == 1)):
                    continue
                
                
                # 2nd cond counterclockwise
                dict_item1 = circle_dict.get(ci[i % n])
                dict_item2 = circle_dict.get(ci[j % n])
                dict_item3 = circle_dict.get(ci[k % n])
                
                
                point1 = (dict_item1[0].real, dict_item1[1].real)
                point2 = (dict_item2[0].real, dict_item2[1].real)
                point3 = (dict_item3[0].real, dict_item3[1].real)
                
                if(not (point_maintains_convex(point1, point2, point3))):
                    continue
                
                # 3rd cond
                dict_item4 = circle_dict.get(ci[k + 1])
                dict_item5 = circle_dict.get(ci[k - 1])
                
                example_loop.is_connected
                
                
            
                q[i][j] = 1
                
                
                        
                print(f"ij: {i, j} and k: {k}")
                
    def is_cc():
        pass
                
    def print_matrix(matrix: list[list[int]]):
        n = len(matrix[0])
        for i in range(n):
            print(matrix[i])
                
                
            
    def point_maintains_convex(b: tuple, a: tuple, c: tuple) -> bool:
        vA = np.array([a[0] - b[0], 0, a[1] - b[1]], float) # b->a
        vB = np.array([c[0] - b[0], 0, c[1] - b[1]], float) # b->c
        
        #vA_mag = math.sqrt(math.pow(vA[0], 2) * math.pow(vA[1], 2))
        #vB_mag = math.sqrt(math.pow(vB[0], 2) * math.pow(vB[1], 2))
        
        #vA_n = np.array([vA[0] / vA_mag, vA[1] / vA_mag], float)
        #vB_n = np.array([vB[0] / vB_mag, vB[1] / vB_mag], float)
        
        #dotProd = vA[0]*vB[0] + vA[1]*vB[1]
        #math.acos(dotProd / (vA_mag * vB_mag)) not for all quadrants 
        #math.degrees(math.acos(vA_n[0]))

        # rearranged law of cosines and dot product to get inner product space
        
        vA_u = vA / np.linalg.norm(vA)
        vB_u = vB / np.linalg.norm(vB)
        angleBetween = math.degrees(np.arccos(np.clip(np.dot(vA_u, vB_u), -1.0, 1.0)))
        
        #cross_prod = vA_mag * vB_mag * math.sin(angleBetween) * np.array[0, 1, 0]
        cross_prod = np.linalg.cross(vA, vB)
        if(cross_prod[1] > 0):
            return True
        else:
            return False
    
    build_matrix(loop_to_circles["sequences"], loop_to_circles["assignments"], packed_circles)   
    print_matrix(q) 